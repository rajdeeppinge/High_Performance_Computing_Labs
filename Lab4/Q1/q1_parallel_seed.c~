/* Parallel Programme to calculate value of pi using random numbers by monte-carlo method.*/

#include <stdio.h>
#include <stdlib.h>
#include <omp.h>

/*
Note: rand function has a internal RNG state 
Every thread has to wait to get the next random number. Otherwise, the same number would be generated by all the threads. not correct.
Therefore mutual exclusion. slowing things down.

Solution: Use private seeds.
*/

/* function to calculate pi using random numbers
	input: number of points to take
	output: approx value of pi
*/
void pi_rand(int N)
{
	int i, n=0; // number of points lying inside the circle of diametre 2 units
	double x_cor, y_cor;

	double par_start= omp_get_wtime();
	unsigned int seed;

	#pragma omp parallel reduction(+:n) \
		 private (seed,x_cor,y_cor)
	{
		//seed = 25234 + 17 * omp_get_thread_num();
		seed = omp_get_thread_num();				// making sure that each thread gets a unique seed

		#pragma omp for
		for (i=0;i<N;i++)
		{
			// getting a random point
			x_cor = (rand_r(&seed)/(double)RAND_MAX);
			y_cor = (rand_r(&seed)/(double)RAND_MAX);

			// if point lies inside the circle, increment count
			if ((x_cor*x_cor + y_cor*y_cor) <1)
				n++;
		}

	}	
	double par_end = omp_get_wtime();

	// printing approx value of pi
//	printf("Approx value of pi : %f\n",4*((double)n)/N);
	printf("MFLOPS = %f\n", 6 * N / (1000000*(par_end-par_start)));  
}

int main(int argc, char* argv[])
{
	int N = atoi(argv[1]);	// number of points to take

	double start,end;

	start= omp_get_wtime();	//start time
	pi_rand(N);				//function to calculate pi using random numbers
	end= omp_get_wtime();	// end time

	printf("time: %f\n",end-start);
	return 0;
}
